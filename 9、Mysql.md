### 1、mysql的设计架构

​	解析器、优化器、执行器、缓存

### 2、mysql的redo log 日志 --**保证事务的持久性**

​	redo log，重做日志。保证当mysql服务器意外宕机时，已经提交的事务持久化到磁盘中。

​	InnoDB是以页为单位操作记录，增删改会加载整个页到buffer pool中。(磁盘->内存)

​	事务中的操作不会直接修改磁盘数据库，而是先修改内存中buffer pool的数据，后台线程定时	刷新到磁盘。

​	

​	不通过redo log 刷盘原因：直接操作磁盘，随机IO 效率低

​	通过redo log刷盘：顺序IO，顺序高

​	

​	redo log 两部分组成

​	redo log buffer: 内存层面，默认16M

​	redo log file：持久化的，磁盘层面

​	

​	redo log 刷盘策略： 

​	0：每秒定时刷新，存在1s的数据丢失

​	1： 事务提交时刷新 （默认）

​	2：事务提交时，只是刷新到OS的内核缓冲区，具体的刷盘时间不确定



### 3、mysql的undo log 日志 --**保证事务的原子性、一致性**

​	主要用于mysql的事务回滚，及MVCC

​	InnoDB RR模式下每次开启一个事务，只会生成一个ReadView。

​	InnoDB RC模式下针对记录每次的insert、update、delete 都会生成一个新的ReadView。

​	

​	对记录的每次insert，update，delete 都会生成新的undo log。undo log 通过 事务id 关联，

​	生成版本链，每条记录都会有三个隐藏字段

​	DB_ROW_ID：记录的主键ID

​	DB_TRX_ID：事务ID，当对某条记录发生修改时，就会将事务的ID记录其中

​	DB_ROLL_PTR：回滚指针，版本链中的指针。

​	

	### 4、mysql的bin log 日志

  binlog 即binary log，二进制日志文件，也叫作变更日志(update log)。它记录了数据库所有执

  行的更新语句。





### 5、mysql的索引

​	索引其实一种数据结构，底层是b+tree

​	特点：根节点和枝节点不保存数据，只有叶子节点保存数据。叶子节点数据是顺序的，并在通

​	聚簇索引维护的。

​	聚簇索引：可以理解为主键索引，可以保存记录唯一的。

​	非聚簇索引：也可以理解为二级索引，除了聚簇索引的都是非聚簇索引或者辅助索引。

​	通过非聚簇索引检索数据，都要经过回表。

​	索引优化：

​	1、函数会导致索引失效

​	2、表达式会导致索引失效

​	3、子查询条件的顺序会导致索引失效

​	4、group by having 也会导致索引失效

​	5、模糊查询会导致索引失效

​	

​	设置索引需要注意的：

​	索引字段的散列度要高，说白了就是没有重复的值

​	文本类型不适合做索引

​	

### 6、mysql的锁

